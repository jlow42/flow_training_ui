"""PyInstaller integration for Flow Training UI."""
from __future__ import annotations

import os
import platform
import shutil
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Sequence, Tuple

from packaging_tools.environment import collect_environment_snapshot, write_environment_snapshot

try:  # pragma: no cover - import guard for optional dependency
    from PyInstaller.__main__ import run as pyinstaller_run
except Exception:  # pragma: no cover - PyInstaller missing at runtime
    pyinstaller_run = None  # type: ignore[assignment]


@dataclass
class BundleResult:
    dist_path: Path
    artifact_path: Path


def ensure_pyinstaller() -> None:
    """Ensure PyInstaller is available, raising ``RuntimeError`` otherwise."""

    if pyinstaller_run is None:
        raise RuntimeError(
            "PyInstaller is not available. Install it via `pip install pyinstaller` before bundling."
        )


def detect_default_data_paths(project_root: Path) -> List[Tuple[Path, str]]:
    """Return ``(source, destination)`` tuples for static data to ship with bundles."""

    candidates: List[Tuple[Path, str]] = []
    data_dirs = ["sample_data", "training_fcs", "Applications"]
    for directory in data_dirs:
        path = project_root / directory
        if path.exists():
            candidates.append((path, directory))
    return candidates


def _format_add_data_argument(source: Path, target: str) -> str:
    separator = ";" if platform.system() == "Windows" else ":"
    return f"{source}{separator}{target}"


def locate_bundle_artifact(dist_dir: Path, app_name: str, onefile: bool) -> Path:
    """Determine the bundle artifact path generated by PyInstaller."""

    if platform.system() == "Windows" or os.name == "nt":
        executable_name = f"{app_name}.exe"
    elif platform.system() == "Darwin":
        if onefile:
            executable_name = app_name
        else:
            bundle_dir = dist_dir / f"{app_name}.app"
            if bundle_dir.exists():
                return bundle_dir
            executable_name = app_name
    else:
        executable_name = app_name

    candidate = dist_dir / executable_name
    if not candidate.exists():
        raise FileNotFoundError(
            f"Expected bundle artifact '{candidate}' not found. Verify the PyInstaller configuration."
        )
    return candidate


def build_pyinstaller_bundle(
    app_path: Path,
    output_dir: Path,
    *,
    name: str = "FlowTrainingUI",
    onefile: bool = False,
    windowed: bool = True,
    clean: bool = True,
    icon: Optional[Path] = None,
    add_data: Optional[Sequence[Tuple[Path, str]]] = None,
    extra_args: Optional[Sequence[str]] = None,
    snapshot: bool = True,
) -> BundleResult:
    """Build a PyInstaller bundle and return its location."""

    ensure_pyinstaller()

    output_dir.mkdir(parents=True, exist_ok=True)
    build_dir = output_dir / "build"
    dist_dir = output_dir / "dist"
    spec_dir = output_dir / "spec"

    for path in (build_dir, dist_dir, spec_dir):
        if path.exists() and clean:
            if path.is_dir():
                shutil.rmtree(path)
            else:
                path.unlink()
        path.mkdir(parents=True, exist_ok=True)

    cmd: List[str] = [
        str(app_path),
        "--name",
        name,
        "--distpath",
        str(dist_dir),
        "--workpath",
        str(build_dir),
        "--specpath",
        str(spec_dir),
    ]

    if onefile:
        cmd.append("--onefile")
    else:
        cmd.append("--onedir")

    if windowed:
        cmd.append("--noconsole")

    if clean:
        cmd.append("--clean")

    if icon is not None:
        cmd.extend(["--icon", str(icon)])

    for source, target in add_data or []:
        cmd.extend(["--add-data", _format_add_data_argument(source, target)])

    if extra_args:
        cmd.extend(extra_args)

    pyinstaller_run(cmd)

    artifact = locate_bundle_artifact(dist_dir, name, onefile)

    if snapshot:
        snapshot_dir = output_dir / "snapshots"
        snapshot = collect_environment_snapshot(cwd=app_path.parent)
        snapshot_path = snapshot_dir / f"{name}_environment.json"
        write_environment_snapshot(snapshot, snapshot_path)

    return BundleResult(dist_dir, artifact)


def validate_bundle_artifact(artifact: Path, expected_platforms: Optional[Sequence[str]] = None) -> None:
    """Perform basic validation of the generated bundle.

    Parameters
    ----------
    artifact:
        Path to the created bundle (either the executable file or the ``.app``
        directory on macOS).
    expected_platforms:
        Optional iterable of platform identifiers (``"linux"``, ``"darwin"``,
        ``"win"``). The function ensures the artifact matches one of the provided
        platform expectations. If ``None`` the current platform is assumed.
    """

    if not artifact.exists():
        raise FileNotFoundError(f"Bundle artifact '{artifact}' does not exist")

    platforms = list(expected_platforms) if expected_platforms else [sys.platform]
    suffix = artifact.suffix.lower()

    if any(p.startswith("win") for p in platforms):
        if suffix != ".exe":
            raise ValueError("Windows bundles should have a .exe suffix")
    elif any(p.startswith("darwin") or p.startswith("mac") for p in platforms):
        if artifact.is_dir():
            if not artifact.name.endswith(".app"):
                raise ValueError("macOS bundles should end with .app")
        elif suffix not in {"", ".app"}:
            raise ValueError("macOS one-file bundles should be bare executables")
    else:
        # Linux / Unix-like validation
        if artifact.is_dir():
            raise ValueError("Linux bundles are expected to be executables, not directories")
        if not os.access(artifact, os.X_OK):
            raise PermissionError("Bundle is not marked as executable")


def generate_platform_matrix() -> List[str]:
    """Helper used by tests to document supported platform checks."""

    return ["linux", "darwin", "win32"]


__all__ = [
    "BundleResult",
    "ensure_pyinstaller",
    "detect_default_data_paths",
    "build_pyinstaller_bundle",
    "locate_bundle_artifact",
    "validate_bundle_artifact",
    "generate_platform_matrix",
]
